%! Author = zjs
%! Date = 6/27/22

% Preamble
\documentclass{ctexbeamer}
% Packages
\usepackage{braket}
\usepackage{fancyvrb}
%\usepackage[outputDir=../out, hybrid]{markdown}
\usepackage{textcomp}
\usepackage{amsmath}

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\green}[1]{\textcolor{green}{#1}}
\newcommand{\gray}[1]{\textcolor{gray}{#1}}
\newcommand{\lime}[1]{\textcolor{lime}{#1}}
\newcommand{\purple}[1]{\textcolor{purple}{#1}}
\newcommand{\str}[1]{\texttt{#1}}
\newcommand{\fail}{\mathsf{fail}}

\DefineVerbatimEnvironment%tight verbatim
{tverb}{Verbatim} %在tverb环境里，verbamtim 的 \, {, } 需要escape。
{commandchars=\\\{\},baselinestretch=0,frame=bottomline, fontsize=\small}


\DefineVerbatimEnvironment%tight verbatim
{bverb}{BVerbatim}
{commandchars=\\\{\},baselinestretch=0, fontsize=\small}

\DefineVerbatimEnvironment%tight verbatim for code
{cverb}{BVerbatim}
{baselinestretch=0, fontsize=\small}


% Document
\begin{document}
\title{KMP算法}
\author{邹家树}
\institute{小码王}
\maketitle

\begin{frame}[fragile]
	\frametitle{问题：字符串匹配}

\begin{itemize}
\item 字符串下标从1开始。
\item 字符串 $S$ 的第 $i$ 个字符记作 $S_i$。
\end{itemize}

    模式串$P$，文本串$T$。
    模式串在文本串的哪些地方出现过？
    $P=\str{aba}$，$T=\str{ababa}$。答案：$\set{1, 3}$。

\begin{itemize}
\item 文本串长度记作 $n$
\item 模式串长度记作 $m$
\end{itemize}

若 $T_{i..m+i-1} = P$ 则称 $i$ 是\emph{匹配点}。

\end{frame}


\begin{frame}[fragile]
\frametitle{暴力匹配算法}

\begin{itemize}
\item 第$i$次匹配：把模式串开头和文本串第$i$个字符对齐，从头开始比较。遇到文本串和模式串里对应字符不相同（称为失配）就停止。
\item 共匹配 $n-m+1$次。
\end{itemize}


\begin{cverb}
for (int i = 1; i <= n - m + 1; i++) {
  int j;
  for (j = 1; j <= m; j++)
    if (T[i + j - 1] != P[j]) break;
  if (j > m)
    i是匹配点。
}
\end{cverb}

\end{frame}

\begin{frame}[fragile]
\frametitle{暴力匹配算法示例}
P= \texttt{abcabcacab}，T=\texttt{babcbabcabcaabcabcabcacabc}。

\begin{minipage}[t]{0.5\textwidth}
\begin{tverb}
abcabcacab \(1\)
\red{b}abcbabcabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
 abcabcacab \(4\)
b\green{abc}\red{b}abcabcaabcabcabcacabc
\end{tverb}


\begin{tverb}
  abcabcacab \(1\)
ba\red{b}cbabcabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
   abcabcacab \(1\)
bab\red{c}babcabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
    abcabcacab \(1\)
babc\red{b}abcabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
     abcabcacab \(8\)
babcb\green{abcabca}\red{a}bcabcabcacabc
\end{tverb}

\begin{tverb}
      abcabcacab \(1\)
babcba\red{b}cabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
       abcabcacab \(1\)
babcbab\red{c}abcaabcabcabcacabc
\end{tverb}

\begin{tverb}
        abcabcacab \(5\)
babcbabc\green{abca}\red{a}bcabcabcacabc
\end{tverb}

\end{minipage}%
\begin{minipage}[t]{.5\textwidth}

\begin{tverb}
         abcabcacab \(1\)
babcbabca\red{b}caabcabcabcacabc
	\end{tverb}

\begin{tverb}
          abcabcacab \(1\)
babcbabcab\red{c}aabcabcabcacabc
\end{tverb}

\begin{tverb}
           abcabcacab \(2\)
babcbabcabc\green{a}\red{a}bcabcabcacabc
    	\end{tverb}

\begin{tverb}
            abcabcacab \(7\)
babcbabcabca\green{abcabca}\red{b}cacabc
            	\end{tverb}

\begin{tverb}
             abcabcacab \(1\)
babcbabcabcaa\red{b}cabcabcacabc
\end{tverb}

\begin{tverb}
              abcabcacab \(1\)
babcbabcabcaab\red{c}abcabcacabc
            	\end{tverb}

\begin{tverb}
               abcabcacab \(10\)
babcbabcabcaabc\green{abcabcacab}c
\end{tverb}

\begin{tverb}
                abcabcacab \(1\)
babcbabcabcaabca\red{b}cabcacabc
\end{tverb}


\end{minipage}



一共比较了 $47$ 次。

\end{frame}

\begin{frame}
	\frametitle{暴力匹配算法的时间复杂度}

最坏情况时间复杂度是 $O(nm)$。


P=\texttt{aaaaaaab}，T=\texttt{aaaaaaaaaaaaaaaaaaaab}。
\end{frame}

\begin{frame}[fragile]
\frametitle{改进暴力匹配算法}

观察暴力匹配算法前五次匹配过程。

	\begin{tverb}
abcabcacab \(1\)
\red{b}abcbabcabcaabcabcabcacabc
	\end{tverb}

\begin{tverb}
 abcabcacab \(4\)
b\green{abc}\red{b}abcabcaabcabcabcacabc
	\end{tverb}


	\begin{tverb}
  abcabcacab \(1\)
ba\red{b}cbabcabcaabcabcabcacabc
	\end{tverb}

	\begin{tverb}
   abcabcacab \(1\)
bab\red{c}babcabcaabcabcabcacabc
	\end{tverb}

	\begin{tverb}
    abcabcacab \(1\)
babc\red{b}abcabcaabcabcabcacabc
	\end{tverb}

从``第二次失配发生在$P_4$处''，我们可以知道关于文本串$T$的两件事：
\begin{itemize}
\item $T$ 的第二到第四个字符等于 $P$ 的前三个字符（\str{abc}）。
\item $T_5$不等于$P_4$（\str{a}）。
\end{itemize}
用这两个条件就能断定随后的三次匹配在$P_1$处就失配。

充分挖模式串的特点，失配信息可以用来预判之后的匹配结果。

\end{frame}

\begin{frame}[fragile]
\frametitle{改进暴力匹配算法}

\begin{tverb}
abcabcacab
\red{b}abcbabcabcaabcabcabcacabc \(1\)
\end{tverb}

	\begin{tverb}
 abcabcacab
b\green{abc}\red{b}abcabcaabcabcabcacabc \(4\)
	\end{tverb}

\begin{tverb}
     abcabcacab
ba\gray{bcb}abcabcaabcabcabcacabc
\end{tverb}

\begin{tverb}
     abcabcacab
babcb\green{abcabca}\red{a}bcabcabcacabc \(8\)
\end{tverb}

\begin{tverb}
        abcabcacab
babcbabc\lime{abca}\purple{a}bcabcabcacabc
\end{tverb}

\begin{tverb}
        abcabcacab
babcbabc\lime{abca}\red{a}bcabcabcacabc \(1\)
\end{tverb}

\begin{tverb}
            abcabcacab
babcbabca\gray{bca}\purple{a}bcabcabcacabc
\end{tverb}

\begin{tverb}
            abcabcacab
babcbabcabca\green{abcabca}\red{b}cacabc \(8\)
\end{tverb}

\begin{tverb}
               abcabcacab
babcbabcabcaa\gray{bc}\lime{abca}\purple{b}cacabc
\end{tverb}

\begin{tverb}
               abcabcacab
babcbabcabcaabc\lime{abca}\green{bcacab}c \(6\)
\end{tverb}

\begin{tverb}
                       abcabcacab
babcbabcabcaabca\gray{bcabcac}\lime{ab}c           一共比较了\(28\)次
\end{tverb}

\end{frame}

\begin{frame}[fragile]
\frametitle{改进暴力匹配算法}


当 $T_i$ 和 $P_j$ 失配时（此时 $P_1$ 和 $T_{i - j + 1}$对齐），用
\begin{itemize}
\item $P_{1..j-1} = T_{i - j + 1..i-1}$
\item $P_j \ne T_i$
\end{itemize}
两条件找$\set{i - j + 2, \dots, i}$里下一个可能的匹配点。

\begin{block}{}
对于 $k = i - j + 2, \dots, i - 1$，$k$ 是匹配点的必要条件有
\begin{itemize}
\item $P_{1..i-k} = T_{k..i-1} $ 即 $P_{1..i-k} = P_{j - i+k ..j - 1}$
\item $P_{i - k + 1} \ne P_j$
\end{itemize}

$i$ 是匹配点的必要条件有
\begin{itemize}
\item $P_1 \ne P_j$
\end{itemize}

\end{block}


\begin{block}{要点}
\begin{itemize}
\item 用来找下一个可能的匹配点的条件都是关于模式串$P$的。
\item 找到下一个可能的匹配点 $k$ 之后就从 $T_i$ 和 $P_{i - k + 1}$ 开始继续比较，不必从 $T_k$ 和 $P_1$ 开始比较。
\end{itemize}
\end{block}



\end{frame}

\begin{frame}
\frametitle{改进暴力匹配算法}
充分利用模式串 $P$ 的特点，事先算出一个函数fail。

\begin{itemize}
\item $\text{fail}(j)$ := 匹配过程中遇到$T_i$ 和 $P_j$ 失配时，接着拿 $T_i$ 和 $P_{\text{fail}(j)}$ 比较。
\item $\text{fail}(j) = 0$ 意味着下一个可能的匹配点是 $i+1$。
\end{itemize}




%abcabcacab
%         abcab
\begin{table}[]
\begin{tabular}{llllllllllll}
下标$j$ & 1  & 2  & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
$S_j$ & \str{a} & \str{b} & \str{c} & \str{a} & \str{b} & \str{c} & \str{a} & \str{c} & \str{a}  & \str{b} \\
fail($j$) & 0  & 1  & 1 & 0 & 1 & 1 & 0 & 5  & 0  & 1
\end{tabular}
\end{table}

\begin{block}{}
如何计算 fail 函数？
\end{block}




\end{frame}

\begin{frame}{恰当前缀，前后缀}

\begin{block}{恰当前缀}
  对于非空字符串 $S$，设 $S$ 的长度是 $n$。我们把 $S$ 的长度\emph{小于} $n$ 的前缀称为 $S$ 的\emph{恰当前缀}（proper prefix，也可译作``严格前缀''）。

  例如，$S= \str{abc}$ 则 $S$ 的恰当前缀有：空串，\str{a}，\str{ab}。
\end{block}

\begin{block}{前后缀}
对于非空字符串 $S$，若字符串 $T$ 既是 $S$ 的恰当前缀也是 $S$ 的后缀，则称 $T$ 为 $S$ 的前后缀。例如 \str{abc} 的前后缀有：空串；\str{ababa} 的前后缀有：空串，\str{a}，\str{aba}；
\str{aaa} 的前后缀有：空串，\str{a}，\str{aa}。

任何非空字符串都有前后缀。
\end{block}

\end{frame}


\begin{frame}
\frametitle{计算fail函数}

\begin{block}{}
\begin{itemize}
  \item 边界条件：$\text{fail}(1) = 0$。
  \item 对于 $j = 2, 3, \dots, m$，若 $1, \dots, j - 1$ 中存在 $k$ 满足
  {
  \begin{itemize}
  \item $P_{1..k - 1} = P_{j - (k - 1) .. j - 1}$ 且 $P_{k} \ne P_j$。
  \end{itemize}
  则 $\fail(j) = $满足此条件的最大的 $k$，否则 $\fail(j) = 0$。
  }
  \end{itemize}
\end{block}





对于 $j = 2, \dots, m$，当 $T_i$和 $P_j$ 失配时，我们做两件事：

\begin{itemize}
    \item 先用 $P_{1..k - 1} = P_{j - (k - 1) .. j - 1}$ 这个条件把
          模式串尽可能少地往右移动一些。也就是说，
          我们先从 $0, \dots, j - 2$ 中找到一个最大的整数 $t$ 满足 $P_{1..t} = P_{j-t .. j-1}$。$P_{1..t}$ 就是 $P_{1..j-1}$ 的最长前后缀。
          把 $P$ 向右移动一些，使 $P_{t}$ 和 $T_{i - 1}$ 对齐。（向右移动 $j - 1 - t$格，$P_1$ 和 $T_{i - t}$ 对齐）。 % P_l 和 T_{i-1} 对齐，P_1 和
% j --
    \item 然后看 $P_{t +1}$ 是否等于 $P_j$，若 $P_{t + 1} \ne P_{j}$，则 $T_{i}$ 有可能等于 $P_{t + 1}$（ $i - t$ 可能是匹配点），
    接着从 $T_i$ 和 $P_{t +1}$ 继续比较，
    于是 $\fail(j) = t + 1$。
    否则 $T_{i}$ 一定不等于 $P_{t + 1}$，换言之，从 $T_{i-t}$ 开始匹配会在 $P_{t + 1}$ 处失配，于是 $\fail(j) = \fail(t + 1)$。
\end{itemize}

\end{frame}

\begin{frame}[fragile]{计算fail函数：例一}
\begin{tverb}
 abcabcacab
\gray{b}\green{abc}\red{b}abcabcaabcabcabcacabc
\end{tverb}
我们要计算 $\fail(4)$。

$P_{1..3}$ 的最长前后缀长度是 $0$，先把 $P$ 向右移动 $3$ 格，使得 $P_1$ 和 $T_5$ 对齐。

\begin{tverb}
    abcabcacab
\gray{babc}\red{b}abcabcaabcabcabcacabc
\end{tverb}

由 $P_4 \ne T_5$ 且 $P_1 = P_4$ 可知 $P_1 \ne T_5$，换言之，
当在 $P_4$ 处失配时，把 $P$ 右移三格，一定会在 $P_1$ 处失配，进而知 $\fail(4) = \fail(1) = 0$。

\begin{tverb}
     abcabcacab
\gray{babcb}abcabcaabcabcabcacabc
\end{tverb}

\end{frame}
\begin{frame}[fragile]{计算fail函数：例二}
\begin{tverb}
     abcabcacab
\gray{babcb}\green{abcabca}\red{a}bcabcabcacabc
\end{tverb}
在 $P_8$ 处失配，$P_{1..7}$（\str{abcabca}） 的最长前后缀是 \str{abca}，先把 $P$ 右移 $7 - 4 = 3$ 格
\begin{tverb}
        abcabcacab
\gray{babcbabc}\lime{abca}\purple{a}bcabcabcacabc
\end{tverb}
$P_5 \ne P_8$，所以 $\fail(8) = 5$。
\end{frame}

\begin{frame}[fragile]{$P_{1..j}$的最长前后缀}
\begin{itemize}
    \item 我们得到了递推计算 $\fail$ 函数的方法。
    \item 算出 $\fail(j)$ 后，为了计算 $\fail(j + 1)$，我们要计算 $P_{1..j}$ 的最长前后缀的长度。
\end{itemize}

%考虑文本串 $T$ 等于模式串 $P$ 的情形。
以计算$P_{1..5} = \str{abcab}$的最长前后缀的长度为例。此时我们知道 $P_{1..4}$ 的最长前后缀的长度是 $1$，因此 $P_{1..5}$ 的最长前后缀长度不超过 $2$。
我们先看 $P_{1..5}$的最长前后缀的长度是否可能等于 $2$，此时的情形相当于
\begin{tverb}
   abcabcacab （这是模式串）
abc\lime{a}bcacab    （这是文本串）
\end{tverb}
我们要比较 $P_2$ 和 $P_5$，$P_2 = P_5$，情形变为
\begin{tverb}
   abcabcacab （这是模式串）
abc\lime{a}\green{b}cacab    （这是文本串）
\end{tverb}
于是知 $P_{1..5}$ 的最长前后缀的长度是 $2$。

\begin{tverb}
   abcabcacab （这是模式串）
abc\lime{ab}\green{c}acab    （这是文本串）
\end{tverb}

\end{frame}




\begin{frame}[fragile]{$P_{1..j}$的最长前后缀}

\begin{tverb}
   abcabcacab （这是模式串）
abc\lime{abc}\green{a}cab    （这是文本串）
\end{tverb}

\begin{tverb}
   abcabcacab （这是模式串）   \(\fail(5)=1\)
abc\lime{abca}\red{c}ab    （这是文本串）
\end{tverb}

\begin{tverb}
       abcabcacab （这是模式串）   \(\fail(1)=0\)
abcabca\red{c}ab    （这是文本串）
\end{tverb}

\begin{tverb}
        abcabcacab （这是模式串）
abcabcacab    （这是文本串）
\end{tverb}

对于 $j = 2, \dots, m$，求 $P_{1..j}$ 的最长前后缀的长度就相当于从
\begin{tverb}
 abcabcacab （这是模式串）
abcabcacab    （这是文本串）
 \(\uparrow\)
 j
\end{tverb}
开始的字符串匹配过程。
\end{frame}

\begin{frame}[fragile]{代码}
\begin{cverb}
fail[1] = 0;
int t = 1;
for (int j = 2; j <= m; j++) {
// t = P[1..j - 1]的最长前后缀的长度加一
  if (P[j] != P[t])
    fail[j] = t;
  else
    fail[j] = fail[t];
  while (t != 0 and P[t] != P[j])
    t = fail[t];
  ++t;
}
fail[m + 1] = t;

int j = 1;
for (int i = 1; i <= n; i++) {
  while (j != 0 and P[j] != T[i])
    j = fail[j];
  j++;
  if (j > m) {
    i - m + 1 是匹配点;
    j = fail[j];
  }
}
\end{cverb}
\end{frame}
\end{document}
%